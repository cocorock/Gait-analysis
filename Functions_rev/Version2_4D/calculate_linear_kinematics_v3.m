%% calculate_linear_kinematics_v3: Calculates angular derivatives and then linear kinematics.
%
% Credits:
%   Victor Ferman, Adrolab FEEC/UNICAMP
%   (Modified by Gemini)
%
% Description:
%   This function first calculates the angular velocity and acceleration for the
%   hip and knee joints from the filtered position data using calc_circular_derivative.
%   It then computes the forward kinematics (position, velocity, and acceleration) 
%   of the end-effector (ankle) and rotates the results by a specified angle phi.
%   This version is adapted to work with the 'processed_data' structure
%   generated by 'apply_filtering_V3', which only contains filtered positions.
%
% Input:
%   processed_data - struct: A structure containing the filtered gait cycle data from V3.
%                     It must contain fields like 'right_hip_flex_filtered', etc.
%   phi  - scalar: The rotation angle in degrees.
%
% Output:
%   linear_kinematics - struct: A structure containing the linear kinematics for both legs.

function linear_kinematics = calculate_linear_kinematics_v3(processed_data, phi)

    % Constants
    l1 = 0.3874;  % length of first link (hip to knee)
    l2 = 0.4136;  % length of second link (knee to ankle)

    % Time step for derivative calculation
    dt = mean(diff(processed_data.time_standard));

    % Convert phi to radians for rotation matrix
    phi_rad = deg2rad(phi);
    R = [cos(phi_rad), -sin(phi_rad);
         sin(phi_rad),  cos(phi_rad)];

    % Initialize output structure
    linear_kinematics = struct();
    linear_kinematics.right_leg_kinematics = [];
    linear_kinematics.left_leg_kinematics = [];

    % Helper function for forward kinematics calculation (unchanged from v2)
    function [pos_rotated, vel_rotated, acc_rotated] = calculate_ankle_kinematics(hip_flex_filtered, knee_flex_filtered, hip_flex_velocity, knee_flex_velocity, hip_flex_acceleration, knee_flex_acceleration, R, l1, l2)
        theta1 = deg2rad(hip_flex_filtered);     % hip angle
        theta2 = deg2rad(knee_flex_filtered);     % knee angle

        theta1_dot = deg2rad(hip_flex_velocity);
        theta2_dot = deg2rad(knee_flex_velocity);

        theta1_ddot = deg2rad(hip_flex_acceleration);
        theta2_ddot = deg2rad(knee_flex_acceleration);

        % 1. Forward Kinematics: End-effector position
        x = l1*cos(theta1) + l2*cos(theta1 + theta2);
        y = l1*sin(theta1) + l2*sin(theta1 + theta2);

        % 2. Jacobian Matrix (2x2 for each time step)
        J11 = -l1*sin(theta1) - l2*sin(theta1 + theta2);  % dx/dtheta1
        J12 = -l2*sin(theta1 + theta2);                   % dx/dtheta2
        J21 = l1*cos(theta1) + l2*cos(theta1 + theta2);   % dy/dtheta1
        J22 = l2*cos(theta1 + theta2);                    % dy/dtheta2

        % 3. Velocity Kinematics: v = J * theta_dot
        x_dot = J11.*theta1_dot + J12.*theta2_dot;
        y_dot = J21.*theta1_dot + J22.*theta2_dot;

        % 4. Acceleration Kinematics: a = J * theta_ddot + dJ/dt * theta_dot
        % Time derivative of Jacobian elements
        dJ11_dt = -l1*cos(theta1).*theta1_dot - l2*cos(theta1 + theta2).*(theta1_dot + theta2_dot);
        dJ12_dt = -l2*cos(theta1 + theta2).*(theta1_dot + theta2_dot);
        dJ21_dt = -l1*sin(theta1).*theta1_dot - l2*sin(theta1 + theta2).*(theta1_dot + theta2_dot);
        dJ22_dt = -l2*sin(theta1 + theta2).*(theta1_dot + theta2_dot);

        % Acceleration = J * theta_ddot + J_dot * theta_dot
        x_ddot = J11.*theta1_ddot + J12.*theta2_ddot + dJ11_dt.*theta1_dot + dJ12_dt.*theta2_dot;
        y_ddot = J21.*theta1_ddot + J22.*theta2_ddot + dJ21_dt.*theta1_dot + dJ22_dt.*theta2_dot;

        % Rotate the kinematics
        pos_rotated = R * [x; y];
        vel_rotated = R * [x_dot; y_dot];
        acc_rotated = R * [x_ddot; y_ddot];
    end

    % Process Right Leg Cycles
    if isfield(processed_data, 'right_leg_cycles') && ~isempty(processed_data.right_leg_cycles)
        num_right_cycles = length(processed_data.right_leg_cycles);
        right_leg_kinematics_temp = cell(1, num_right_cycles);

        for i = 1:num_right_cycles
            cycle = processed_data.right_leg_cycles(i);

            % Calculate Angular Derivatives for Right Leg
            right_hip_flex_velocity = calc_circular_derivative(cycle.right_hip_flex_filtered, dt);
            right_hip_flex_acceleration = calc_circular_derivative(right_hip_flex_velocity, dt);
            right_knee_flex_velocity = calc_circular_derivative(cycle.right_knee_flex_filtered, dt);
            right_knee_flex_acceleration = calc_circular_derivative(right_knee_flex_velocity, dt);

            % Calculate Angular Derivatives for Left Leg (within the same cycle)
            left_hip_flex_velocity = calc_circular_derivative(cycle.left_hip_flex_filtered, dt);
            left_hip_flex_acceleration = calc_circular_derivative(left_hip_flex_velocity, dt);
            left_knee_flex_velocity = calc_circular_derivative(cycle.left_knee_flex_filtered, dt);
            left_knee_flex_acceleration = calc_circular_derivative(left_knee_flex_velocity, dt);

            % Calculate kinematics for Right Ankle
            [right_ankle_pos, right_ankle_vel, right_ankle_acc] = calculate_ankle_kinematics(...
                cycle.right_hip_flex_filtered, cycle.right_knee_flex_filtered, ...
                right_hip_flex_velocity, right_knee_flex_velocity, ...
                right_hip_flex_acceleration, right_knee_flex_acceleration, ...
                R, l1, l2);

            % Calculate kinematics for Left Ankle
            [left_ankle_pos, left_ankle_vel, left_ankle_acc] = calculate_ankle_kinematics(...
                cycle.left_hip_flex_filtered, cycle.left_knee_flex_filtered, ...
                left_hip_flex_velocity, left_knee_flex_velocity, ...
                left_hip_flex_acceleration, left_knee_flex_acceleration, ...
                R, l1, l2);

            % Store results
            lin_struct.right_ankle_pos = right_ankle_pos;
            lin_struct.right_ankle_vel = right_ankle_vel;
            lin_struct.right_ankle_acc = right_ankle_acc;
            lin_struct.left_ankle_pos = left_ankle_pos;
            lin_struct.left_ankle_vel = left_ankle_vel;
            lin_struct.left_ankle_acc = left_ankle_acc;

            right_leg_kinematics_temp{i} = lin_struct;
        end
        linear_kinematics.right_leg_kinematics = [right_leg_kinematics_temp{:}];
    end

    % Process Left Leg Cycles
    if isfield(processed_data, 'left_leg_cycles') && ~isempty(processed_data.left_leg_cycles)
        num_left_cycles = length(processed_data.left_leg_cycles);
        left_leg_kinematics_temp = cell(1, num_left_cycles);

        for i = 1:num_left_cycles
            cycle = processed_data.left_leg_cycles(i);

            % Calculate Angular Derivatives for Left Leg
            left_hip_flex_velocity = calc_circular_derivative(cycle.left_hip_flex_filtered, dt);
            left_hip_flex_acceleration = calc_circular_derivative(left_hip_flex_velocity, dt);
            left_knee_flex_velocity = calc_circular_derivative(cycle.left_knee_flex_filtered, dt);
            left_knee_flex_acceleration = calc_circular_derivative(left_knee_flex_velocity, dt);

            % Calculate Angular Derivatives for Right Leg (within the same cycle)
            right_hip_flex_velocity = calc_circular_derivative(cycle.right_hip_flex_filtered, dt);
            right_hip_flex_acceleration = calc_circular_derivative(right_hip_flex_velocity, dt);
            right_knee_flex_velocity = calc_circular_derivative(cycle.right_knee_flex_filtered, dt);
            right_knee_flex_acceleration = calc_circular_derivative(right_knee_flex_velocity, dt);

            % Calculate kinematics for Left Ankle
            [left_ankle_pos, left_ankle_vel, left_ankle_acc] = calculate_ankle_kinematics(...
                cycle.left_hip_flex_filtered, cycle.left_knee_flex_filtered, ...
                left_hip_flex_velocity, left_knee_flex_velocity, ...
                left_hip_flex_acceleration, left_knee_flex_acceleration, ...
                R, l1, l2);

            % Calculate kinematics for Right Ankle
            [right_ankle_pos, right_ankle_vel, right_ankle_acc] = calculate_ankle_kinematics(...
                cycle.right_hip_flex_filtered, cycle.right_knee_flex_filtered, ...
                right_hip_flex_velocity, right_knee_flex_velocity, ...
                right_hip_flex_acceleration, right_knee_flex_acceleration, ...
                R, l1, l2);

            % Store results
            lin_struct.right_ankle_pos = right_ankle_pos;
            lin_struct.right_ankle_vel = right_ankle_vel;
            lin_struct.right_ankle_acc = right_ankle_acc;
            lin_struct.left_ankle_pos = left_ankle_pos;
            lin_struct.left_ankle_vel = left_ankle_vel;
            lin_struct.left_ankle_acc = left_ankle_acc;

            left_leg_kinematics_temp{i} = lin_struct;
        end
        linear_kinematics.left_leg_kinematics = [left_leg_kinematics_temp{:}];
    end
end